$(document).ready(function() {
    'use strict';

    const DB_NAME = 'PairTradeTrackerDB';
    const DB_VERSION = 1;
    const PAIRS_STORE = 'pairs';
    const TRADES_STORE = 'trades';

    let db;
    let currentPair = null;
    let confirmActionModal;
    let allowFractionalShares = false;

    // --- DATABASE MANAGEMENT ---
    const DB = {
        init: function() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (event) => {
                    const dbInstance = event.target.result;
                    if (!dbInstance.objectStoreNames.contains(PAIRS_STORE)) {
                        dbInstance.createObjectStore(PAIRS_STORE, { keyPath: 'id', autoIncrement: true });
                    }
                    if (!dbInstance.objectStoreNames.contains(TRADES_STORE)) {
                        const tradesStore = dbInstance.createObjectStore(TRADES_STORE, { keyPath: 'id', autoIncrement: true });
                        tradesStore.createIndex('pairId', 'pairId', { unique: false });
                    }
                };
                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve(db);
                };
                request.onerror = (event) => {
                    console.error('Database error:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        },
        add: function(storeName, item) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.add(item);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        },
        getAll: function(storeName) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        },
        get: function(storeName, key) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        },
        put: function(storeName, item) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(item);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        },
        delete: function(storeName, key) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(key);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        },
        deletePairAndTrades: function(pairId) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([TRADES_STORE, PAIRS_STORE], 'readwrite');
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
                const tradesStore = transaction.objectStore(TRADES_STORE);
                const pairsStore = transaction.objectStore(PAIRS_STORE);
                const tradesIndex = tradesStore.index('pairId');
                const cursorRequest = tradesIndex.openCursor(IDBKeyRange.only(pairId));
                cursorRequest.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        cursor.delete();
                        cursor.continue();
                    } else {
                        pairsStore.delete(pairId);
                    }
                };
            });
        },
        clearTradesForPair: function(pairId) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([TRADES_STORE], 'readwrite');
                const store = transaction.objectStore(TRADES_STORE);
                const index = store.index('pairId');
                const request = index.openCursor(IDBKeyRange.only(pairId));
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        cursor.delete();
                        cursor.continue();
                    }
                };
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
            });
        },
        clearAllData: function() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([PAIRS_STORE, TRADES_STORE], 'readwrite');
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
                const pairsStore = transaction.objectStore(PAIRS_STORE);
                const tradesStore = transaction.objectStore(TRADES_STORE);
                pairsStore.clear();
                tradesStore.clear();
            });
        },
        getTradesByPairId: function(pairId) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([TRADES_STORE], 'readonly');
                const store = transaction.objectStore(TRADES_STORE);
                const index = store.index('pairId');
                const request = index.getAll(pairId);
                request.onsuccess = () => {
                    const sortedTrades = [...request.result].sort((a, b) => new Date(a.date) - new Date(b.date));
                    resolve(sortedTrades);
                };
                request.onerror = () => reject(request.error);
            });
        },
        bulkAdd: function(storeName, items) {
            return new Promise((resolve, reject) => {
                if (items.length === 0) {
                    return resolve();
                }
                const transaction = db.transaction([storeName], 'readwrite');
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
                const store = transaction.objectStore(storeName);
                items.forEach(item => store.add(item));
            });
        }
    };

    // --- UI MANAGEMENT & RENDERERS ---
    const UI = {
        dateSortOrder: 'asc',
        isToQtyCalculated: true,
        showMainContent: function(shouldShow) {
            if (shouldShow) {
                $('#welcome-message').addClass('d-none');
                $('#main-content').removeClass('d-none');
                $('#pair-configuration').removeClass('d-none');
                $('#delete-pair-btn').prop('disabled', false);
            } else {
                $('#welcome-message').removeClass('d-none');
                $('#main-content').addClass('d-none');
                $('#pair-configuration').addClass('d-none');
                $('#delete-pair-btn').prop('disabled', true);
            }
        },
        populatePairSelector: function(pairs) {
            const selector = $('#pair-selector');
            selector.empty();
            if (pairs.length === 0) {
                this.showMainContent(false);
                selector.append('<option>No pairs created</option>');
            } else {
                this.showMainContent(true);
                pairs.forEach(pair => {
                    selector.append(`<option value="${pair.id}">${pair.pairName}</option>`);
                });
            }
        },
        renderTradeLog: function(trades) {
            const tbody = $('#trade-log-body');
            tbody.empty();
            if (!currentPair) return;

            const NUM_COLUMNS = 12;
            const iconName = this.dateSortOrder === 'asc' ? 'arrow_drop_up' : 'arrow_drop_down';
            $('#date-sort-icon').html(iconName).addClass('material-symbols-outlined icon-inline-sm sort-icon');
            $('.stock-a-qty-header').text(`${currentPair.stockATicker}`);
            $('.stock-b-qty-header').text(`${currentPair.stockBTicker}`);

            const holdingsHistory = Helpers.calculateAllHoldings(trades);
            let combinedData = trades.map((trade, index) => ({
                trade: trade,
                holdings: holdingsHistory[index]
            }));

            combinedData.sort((a, b) => {
                const dateA = new Date(a.trade.date);
                const dateB = new Date(b.trade.date);
                return this.dateSortOrder === 'asc' ? dateA - dateB : dateB - dateA;
            });

            combinedData.forEach(data => {
                const { trade, holdings } = data;
                const swapQty = parseFloat(trade.swapQty);
                const ratio = parseFloat(trade.fromPrice) / parseFloat(trade.toPrice);
                const displayRatio = Helpers.calculatePairRatio(parseFloat(trade.fromPrice), parseFloat(trade.toPrice), trade.fromTicker);
                const qtyDisplayFormat = { minimumFractionDigits: 0, maximumFractionDigits: allowFractionalShares ? 4 : 0 };
                const swapQtyDisplay = swapQty.toLocaleString(undefined, qtyDisplayFormat);
                const toQty = swapQty * ratio;
                const toQtyDisplay = toQty.toLocaleString(undefined, qtyDisplayFormat);
                const editableClass = 'editable-cell';
                const notesIcon = trade.notes ? 'description' : 'note_add';
                const isComplete = trade.isComplete || false;
                const toggleTitle = isComplete ? 'Reset trade to incomplete' : 'Mark trade as complete';

                const row = `
                    <tr data-trade-id="${trade.id}">
                        <td class="${editableClass}" data-field="date">${Helpers.formatDateForDisplay(trade.date)}</td>
                        <td class="${editableClass}" data-field="fromTicker">${trade.fromTicker}</td>
                        <td class="${editableClass}" data-field="swapQty">${swapQtyDisplay}</td>
                        <td class="${editableClass}" data-field="fromPrice">$${parseFloat(trade.fromPrice).toFixed(2)}</td>
                        <td>${trade.toTicker}</td>
                        <td>${toQtyDisplay}</td>
                        <td class="${editableClass}" data-field="toPrice">$${parseFloat(trade.toPrice).toFixed(2)}</td>
                        <td>${displayRatio !== null ? displayRatio.toFixed(4) : 'N/A'}</td>
                        <td>${holdings.qtyA.toLocaleString(undefined, qtyDisplayFormat)}</td>
                        <td>${holdings.qtyB.toLocaleString(undefined, qtyDisplayFormat)}</td>
                        <td>
                            <button class="btn btn-sm notes-icon-btn" title="View/Edit Notes">
                                <span class="material-symbols-outlined">${notesIcon}</span>
                            </button>
                        </td>
                        <td>
                            <button class="btn btn-sm btn-outline-danger delete-trade-btn" data-trade-id="${trade.id}" title="Delete Trade" ${isComplete ? 'disabled' : ''}>
                                <span class="material-symbols-outlined">delete</span>
                            </button>
                            <div class="form-check d-inline-block align-middle ms-2" 
                                 data-bs-toggle="tooltip" 
                                 data-bs-placement="top" 
                                 title="${toggleTitle}">
                                <input class="form-check-input swap-back-toggle" type="checkbox" data-trade-id="${trade.id}" ${isComplete ? 'checked' : ''}>
                            </div>
                        </td>
                    </tr>`;

                const notesContent = `<textarea class="form-control form-control-sm notes-editor" data-field="notes" rows="2" placeholder="Double-click to add/edit notes..." readonly>${trade.notes || ''}</textarea>`;
                const notesRow = `<tr class="notes-row d-none" data-notes-for-trade-id="${trade.id}"><td colspan="${NUM_COLUMNS}">${notesContent}</td></tr>`;

                tbody.append(row);
                tbody.append(notesRow);
            });
        },
        renderNewTradeRow: function() {
            const newTradeBody = $('#new-trade-body');
            newTradeBody.empty();
            if (!currentPair) return;

            const fromOptions = `<option value="${currentPair.stockATicker}">${currentPair.stockATicker}</option><option value="${currentPair.stockBTicker}">${currentPair.stockBTicker}</option>`;
            const newTradeRow = `
                <tr id="new-trade-row">
                    <td><input type="date" id="new-date" class="form-control form-control-sm"></td>
                    <td><select id="new-from-ticker" class="form-select form-select-sm trade-select">${fromOptions}</select></td>
                    <td><input type="number" id="new-swap-qty" class="form-control form-control-sm trade-input" min="0" step="any"></td>
                    <td><input type="number" id="new-from-price" class="form-control form-control-sm trade-input" min="0" step="0.01"></td>
                    <td><input type="text" id="new-to-ticker" class="form-control form-control-sm" disabled></td>
                    <td><input type="text" id="new-to-qty" class="form-control form-control-sm trade-input bg-body-secondary" readonly></td>
                    <td><input type="number" id="new-to-price" class="form-control form-control-sm trade-input" min="0" step="0.01"></td>
                    <td><input type="text" id="new-ratio" class="form-control form-control-sm" disabled></td>
                    <td colspan="3"><textarea id="new-notes" class="form-control form-control-sm" rows="1" placeholder="add note here"></textarea></td>
                    <td><button id="save-trade-btn" class="btn btn-sm btn-success">Save</button></td>
                </tr>`;
            newTradeBody.append(newTradeRow);
            $('#new-date').val(new Date().toISOString().split('T')[0]);
            this.updateToTicker();
            this.updateNumberInputs();
            this.isToQtyCalculated = true;
            this.initializeTooltips();
        },
        renderPerformance: function(trades) {
            const metrics = Helpers.getPerformanceMetrics(trades);
            if (!metrics) {
                $('#initial-state').html('<p class="card-text text-muted">Configure a pair and add a trade to see starting values.</p>');
                $('#current-state').html('<p class="card-text text-muted">No trades logged yet.</p>');
                $('#performance-metrics').html('<p class="card-text text-muted">Awaiting trade data for calculations.</p>');
                return;
            }
            const qtyDisplayFormat = { minimumFractionDigits: 0, maximumFractionDigits: allowFractionalShares ? 4 : 0 };
            $('#initial-state').html(`
                <dl class="row mb-0">
                    <dt class="col-sm-7">${metrics.initial.qtyA.toLocaleString(undefined, qtyDisplayFormat)} ${currentPair.stockATicker}</dt>
                    <dd class="col-sm-5 text-end">$${metrics.initial.valueA.toFixed(2)}</dd>
                    <dt class="col-sm-7">${metrics.initial.qtyB.toLocaleString(undefined, qtyDisplayFormat)} ${currentPair.stockBTicker}</dt>
                    <dd class="col-sm-5 text-end">$${metrics.initial.valueB.toFixed(2)}</dd>
                    <dt class="col-sm-7 border-top pt-2 mt-1">Total Initial Value</dt>
                    <dd class="col-sm-5 text-end border-top pt-2 mt-1"><strong>$${metrics.initial.totalValue.toFixed(2)}</strong></dd>
                </dl>`);
            $('#current-state').html(`
                <dl class="row mb-0">
                    <dt class="col-sm-7">${metrics.current.qtyA.toLocaleString(undefined, qtyDisplayFormat)} ${currentPair.stockATicker}</dt>
                    <dd class="col-sm-5 text-end">$${metrics.current.valueA.toFixed(2)}</dd>
                    <dt class="col-sm-7">${metrics.current.qtyB.toLocaleString(undefined, qtyDisplayFormat)} ${currentPair.stockBTicker}</dt>
                    <dd class="col-sm-5 text-end">$${metrics.current.valueB.toFixed(2)}</dd>
                    <dt class="col-sm-7 border-top pt-2 mt-1">Total Current Value</dt>
                    <dd class="col-sm-5 text-end border-top pt-2 mt-1"><strong>$${metrics.current.totalValue.toFixed(2)}</strong></dd>
                </dl>`);
            const plClass = metrics.performance.totalPL >= 0 ? 'text-success' : 'text-danger';
            $('#performance-metrics').html(`
                <dl class="row mb-0">
                    <dt class="col-sm-8">Total P/L</dt>
                    <dd class="col-sm-4 text-end ${plClass}"><strong>$${metrics.performance.totalPL.toFixed(2)}</strong></dd>
                    <dt class="col-sm-8">Percentage Gain/Loss</dt>
                    <dd class="col-sm-4 text-end ${plClass}"><strong>${metrics.performance.percentageGain.toFixed(2)}%</strong></dd>
                </dl>`);
        },
        updateNumberInputs: function() {
            const step = allowFractionalShares ? 'any' : '1';
            $('#config-stock-a-qty, #config-stock-b-qty, #new-swap-qty').attr('step', step);
        },
        updateToTicker: function() {
            const fromTicker = $('#new-from-ticker').val();
            const toTicker = (fromTicker === currentPair.stockATicker) ? currentPair.stockBTicker : currentPair.stockATicker;
            $('#new-to-ticker').val(toTicker);
        },
        updateCalculatedFields: function() {
            const fromPrice = parseFloat($('#new-from-price').val());
            const swapQty = parseFloat($('#new-swap-qty').val());
            const toQtyInput = $('#new-to-qty');
            const toPriceInput = $('#new-to-price');
            const ratioInput = $('#new-ratio');
            const qtyDisplayFormat = { minimumFractionDigits: allowFractionalShares ? 4 : 0, maximumFractionDigits: allowFractionalShares ? 4 : 0 };

            if (this.isToQtyCalculated) {
                const toPrice = parseFloat(toPriceInput.val());
                if (!isNaN(fromPrice) && fromPrice > 0 && !isNaN(swapQty) && swapQty > 0 && !isNaN(toPrice) && toPrice > 0) {
                    const calculatedToQty = (fromPrice * swapQty) / toPrice;
                    toQtyInput.val(calculatedToQty.toLocaleString(undefined, qtyDisplayFormat));
                } else {
                    toQtyInput.val('');
                }
            }
            const finalToPrice = parseFloat(toPriceInput.val());
            if (!isNaN(fromPrice) && fromPrice > 0 && !isNaN(finalToPrice) && finalToPrice > 0) {
                const fromTicker = $('#new-from-ticker').val();
                const displayRatio = Helpers.calculatePairRatio(fromPrice, finalToPrice, fromTicker);
                ratioInput.val(displayRatio !== null ? displayRatio.toFixed(4) : '');
            } else {
                ratioInput.val('');
            }
        },
        initializeTooltips: function() {
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.map(function(tooltipTriggerEl) {
                const existingTooltip = bootstrap.Tooltip.getInstance(tooltipTriggerEl);
                if (existingTooltip) {
                    existingTooltip.dispose();
                }
                return new bootstrap.Tooltip(tooltipTriggerEl);
            });
        },
        showToast: function(title, message, isError = false) {
            $('#toast-title').text(title);
            $('#toast-body').text(message);
            $('#app-toast').attr('data-toast-type', isError ? 'error' : 'success');
            const appToast = new bootstrap.Toast(document.getElementById('app-toast'));
            appToast.show();
        },
        validateRow: function() {
            let isValid = true;
            const fields = ['#new-date', '#new-swap-qty', '#new-from-price', '#new-to-price'];
            fields.forEach(fieldId => {
                const field = $(fieldId);
                let isFieldValid = true;
                if (field.attr('type') === 'number') {
                    isFieldValid = field.val() && parseFloat(field.val()) > 0;
                } else {
                    isFieldValid = !!field.val();
                }
                if (!isFieldValid) {
                    field.addClass('is-invalid');
                    isValid = false;
                } else {
                    field.removeClass('is-invalid');
                }
            });
            return isValid;
        },
        createCellEditor: function(field, currentValue) {
            if (field === 'fromTicker') {
                const toTicker = (currentValue === currentPair.stockATicker) ? currentPair.stockBTicker : currentPair.stockATicker;
                return `<select class="form-select form-select-sm"><option value="${currentValue}" selected>${currentValue}</option><option value="${toTicker}">${toTicker}</option></select>`;
            }
            if (field === 'date') {
                return `<input type="date" class="form-control form-control-sm" value="${currentValue}">`;
            }
            const step = field === 'swapQty' ? (allowFractionalShares ? 'any' : '1') : '0.01';
            return `<input type="number" class="form-control form-control-sm trade-input" value="${currentValue}" step="${step}">`;
        },
        init: function() {
            confirmActionModal = new bootstrap.Modal(document.getElementById('confirm-action-modal'));
            if (localStorage.getItem('isDataManagementExpanded') === 'true') {
                new bootstrap.Collapse('#data-management-collapse', { toggle: false }).show();
            }
            if (localStorage.getItem('isSettingsExpanded') === 'true') {
                new bootstrap.Collapse('#settings-collapse', { toggle: false }).show();
            }
        }
    };

    // --- HELPERS ---
    const Helpers = {
        calculatePairRatio: function(price1, price2, ticker1) {
            if (!currentPair || !currentPair.stockATicker) return null;
            const { stockATicker } = currentPair;
            let priceA, priceB;
            if (ticker1 === stockATicker) {
                priceA = price1;
                priceB = price2;
            } else {
                priceA = price2;
                priceB = price1;
            }
            if (priceA > 0 && priceB > 0) return priceA / priceB;
            return null;
        },
        formatDateForDisplay: function(dateString) {
            if (!dateString || typeof dateString !== 'string') return 'N/A';
            const parts = dateString.split('-');
            if (parts.length !== 3) return dateString;
            const year = parseInt(parts[0], 10);
            const monthIndex = parseInt(parts[1], 10) - 1;
            const day = parseInt(parts[2], 10);
            const date = new Date(Date.UTC(year, monthIndex, day));
            if (isNaN(date.getTime())) return dateString;
            const monthNames = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
            return `${String(date.getUTCDate()).padStart(2, '0')}-${monthNames[date.getUTCMonth()]}-${date.getUTCFullYear()}`;
        },
        calculateAllHoldings: function(trades) {
            const holdingsHistory = [];
            if (!currentPair) return holdingsHistory;
            let qtyA = parseFloat(currentPair.stockAInitialQty);
            let qtyB = parseFloat(currentPair.stockBInitialQty);
            trades.forEach(trade => {
                const ratio = parseFloat(trade.fromPrice) / parseFloat(trade.toPrice);
                const swapQty = parseFloat(trade.swapQty);
                if (trade.fromTicker === currentPair.stockATicker) {
                    qtyA -= swapQty;
                    qtyB += (swapQty * ratio);
                } else {
                    qtyB -= swapQty;
                    qtyA += (swapQty * ratio);
                }
                let currentQtyA = qtyA;
                let currentQtyB = qtyB;
                if (!allowFractionalShares) {
                    currentQtyA = Math.floor(qtyA);
                    currentQtyB = Math.floor(qtyB);
                }
                holdingsHistory.push({ qtyA: currentQtyA, qtyB: currentQtyB });
                qtyA = currentQtyA;
                qtyB = currentQtyB;
            });
            return holdingsHistory;
        },
        calculateHoldings: function(trades) {
            if (!currentPair) return { qtyA: 0, qtyB: 0 };
            if (trades.length === 0) {
                return { qtyA: parseFloat(currentPair.stockAInitialQty), qtyB: parseFloat(currentPair.stockBInitialQty) };
            }
            const history = this.calculateAllHoldings(trades);
            return history[history.length - 1];
        },
        getPerformanceMetrics: function(trades) {
            if (!currentPair || trades.length === 0) return null;
            const initialQtyA = parseFloat(currentPair.stockAInitialQty);
            const initialQtyB = parseFloat(currentPair.stockBInitialQty);
            const firstTrade = trades[0];
            let initialPriceA, initialPriceB;
            if (firstTrade.fromTicker === currentPair.stockATicker) {
                initialPriceA = parseFloat(firstTrade.fromPrice);
                initialPriceB = parseFloat(firstTrade.toPrice);
            } else {
                initialPriceB = parseFloat(firstTrade.fromPrice);
                initialPriceA = parseFloat(firstTrade.toPrice);
            }
            const initialValueA = initialQtyA * initialPriceA;
            const initialValueB = initialQtyB * initialPriceB;
            const initialTotalValue = initialValueA + initialValueB;
            const finalHoldings = this.calculateHoldings(trades);
            const lastTrade = trades[trades.length - 1];
            let lastPriceA, lastPriceB;
            if (lastTrade.fromTicker === currentPair.stockATicker) {
                lastPriceA = parseFloat(lastTrade.fromPrice);
                lastPriceB = parseFloat(lastTrade.toPrice);
            } else {
                lastPriceB = parseFloat(lastTrade.fromPrice);
                lastPriceA = parseFloat(lastTrade.toPrice);
            }
            const currentValueA = finalHoldings.qtyA * lastPriceA;
            const currentValueB = finalHoldings.qtyB * lastPriceB;
            const currentTotalValue = currentValueA + currentValueB;
            const totalPL = currentTotalValue - initialTotalValue;
            const percentageGain = initialTotalValue > 0 ? (totalPL / initialTotalValue) * 100 : 0;
            return {
                initial: { qtyA: initialQtyA, qtyB: initialQtyB, valueA: initialValueA, valueB: initialValueB, totalValue: initialTotalValue },
                current: { qtyA: finalHoldings.qtyA, qtyB: finalHoldings.qtyB, valueA: currentValueA, valueB: currentValueB, totalValue: currentTotalValue },
                performance: { totalPL: totalPL, percentageGain: percentageGain }
            };
        },
        validateTradeUpdate: async function(trade, field, newValue) {
            let sanitizedValue = newValue;
            if (field !== 'notes') {
                if (field === 'fromPrice' || field === 'toPrice') {
                    sanitizedValue = sanitizedValue.replace('$', '');
                }
                if (field === 'swapQty' || field === 'fromPrice' || field === 'toPrice') {
                    if (isNaN(parseFloat(sanitizedValue)) || parseFloat(sanitizedValue) <= 0) {
                        return { isValid: false, error: 'Price and quantity must be positive numbers.' };
                    }
                }
                const allTrades = await DB.getTradesByPairId(currentPair.id);
                const tradeIndex = allTrades.findIndex(t => t.id === trade.id);
                if (tradeIndex === -1) {
                    return { isValid: false, error: 'Could not find the trade to validate against.' };
                }
                const tradesBefore = allTrades.slice(0, tradeIndex);
                const holdingsBefore = this.calculateHoldings(tradesBefore);
                const fromTicker = field === 'fromTicker' ? sanitizedValue : trade.fromTicker;
                const swapQty = field === 'swapQty' ? parseFloat(sanitizedValue) : parseFloat(trade.swapQty);
                if (fromTicker === currentPair.stockATicker && swapQty > holdingsBefore.qtyA) {
                    return { isValid: false, error: `Swap quantity exceeds holdings for ${fromTicker} at that time.` };
                }
                if (fromTicker === currentPair.stockBTicker && swapQty > holdingsBefore.qtyB) {
                    return { isValid: false, error: `Swap quantity exceeds holdings for ${fromTicker} at that time.` };
                }
            }
            return { isValid: true, sanitizedValue: sanitizedValue };
        },
        validateNewPair: async function(newPair) {
            if (!newPair.pairName || !newPair.stockATicker || !newPair.stockBTicker) {
                return { isValid: false, error: 'All fields are required to create a pair.', field: 'general' };
            }
            const existingPairs = await DB.getAll(PAIRS_STORE);
            if (existingPairs.some(pair => pair.pairName === newPair.pairName)) {
                return { isValid: false, error: `A pair named "${newPair.pairName}" already exists. Please choose a unique name.`, field: 'pair-name' };
            }
            return { isValid: true };
        },
        generateExportFilename: function(pairName) {
            const now = new Date();
            const year = now.getFullYear().toString().slice(-2);
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const dateStr = `${year}${month}${day}`;
            const safePairName = pairName.replace(/\//g, '-');
            return `${dateStr}--${safePairName}-SWAP-DB.csv`;
        },
        generateDemoTrades: function(pair) {
            const trades = [];
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 10);
            for (let i = 0; i < 8; i++) {
                const tradeDate = new Date(startDate);
                tradeDate.setDate(tradeDate.getDate() + i);
                const fromTicker = (i % 2 === 0) ? pair.stockATicker : pair.stockBTicker;
                const toTicker = (i % 2 === 0) ? pair.stockBTicker : pair.stockATicker;
                const swapQty = (Math.random() * 9 + 1).toFixed(allowFractionalShares ? 4 : 0);
                const fromPrice = (80 + Math.random() * 40).toFixed(2);
                const toPrice = (80 + Math.random() * 40).toFixed(2);
                trades.push({
                    pairId: pair.id,
                    date: tradeDate.toISOString().split('T')[0],
                    fromTicker, toTicker, swapQty, fromPrice, toPrice,
                    notes: `Demo trade ${i + 1}`,
                    isComplete: (i < 4)
                });
            }
            return trades;
        },
        validateNewTrade: async function() {
            if (!UI.validateRow()) {
                return { isValid: false, error: 'Please fill all required fields with valid positive numbers.' };
            }
            const allTrades = await DB.getTradesByPairId(currentPair.id);
            const holdingsBefore = this.calculateHoldings(allTrades);
            const fromTicker = $('#new-from-ticker').val();
            const newSwapQty = parseFloat($('#new-swap-qty').val());
            const qtyDisplayFormat = { minimumFractionDigits: 0, maximumFractionDigits: allowFractionalShares ? 4 : 0 };
            if (fromTicker === currentPair.stockATicker && newSwapQty > holdingsBefore.qtyA) {
                $('#new-swap-qty').addClass('is-invalid');
                return { isValid: false, error: `Swap quantity (${newSwapQty.toLocaleString(undefined, qtyDisplayFormat)}) cannot exceed current holding of ${currentPair.stockATicker} (${holdingsBefore.qtyA.toLocaleString(undefined, qtyDisplayFormat)}).` };
            }
            if (fromTicker === currentPair.stockBTicker && newSwapQty > holdingsBefore.qtyB) {
                $('#new-swap-qty').addClass('is-invalid');
                return { isValid: false, error: `Swap quantity (${newSwapQty.toLocaleString(undefined, qtyDisplayFormat)}) cannot exceed current holding of ${currentPair.stockBTicker} (${holdingsBefore.qtyB.toLocaleString(undefined, qtyDisplayFormat)}).` };
            }
            let swapQty = $('#new-swap-qty').val();
            if (!allowFractionalShares) {
                swapQty = Math.floor(parseFloat(swapQty)).toString();
            }
            return {
                isValid: true,
                trade: {
                    pairId: currentPair.id,
                    date: $('#new-date').val(),
                    swapQty: swapQty,
                    fromTicker: fromTicker,
                    fromPrice: $('#new-from-price').val(),
                    toTicker: $('#new-to-ticker').val(),
                    toPrice: $('#new-to-price').val(),
                    notes: $('#new-notes').val().trim(),
                    isComplete: false
                }
            };
        }
    };

    // --- MAIN APP LOGIC & EVENT HANDLERS ---
    const App = {
        init: async function() {
            // Load shared components first
            $("#header-placeholder").load("../../assets/includes/_header.html?v=" + new Date().getTime(), function() {
                if (typeof initializeHeader === 'function') {
                    initializeHeader();
                }
            });
            $("#navbar-placeholder").load("../../assets/includes/_navbar.html?v=" + new Date().getTime());

            allowFractionalShares = localStorage.getItem('allowFractionalShares') === 'true';
            $('#fractional-shares-switch').prop('checked', allowFractionalShares);
            UI.updateNumberInputs();
            try {
                await DB.init();
                UI.init();
                await this.loadPairs();
                this.bindEvents();
            } catch (error) {
                console.error("Failed to initialize the application:", error);
                UI.showToast('Initialization Failed', 'Could not load database. Please refresh.', true);
            }
        },
        loadPairs: async function() {
            const pairs = await DB.getAll(PAIRS_STORE);
            UI.populatePairSelector(pairs);
            if (pairs.length > 0) {
                const lastSelectedPairId = localStorage.getItem('lastSelectedPairId') || pairs[0].id;
                $('#pair-selector').val(lastSelectedPairId);
            }
            await this.loadPairData();
        },
        loadPairData: async function() {
            const selectedIdStr = $('#pair-selector').val();
            if (!selectedIdStr || selectedIdStr === 'No pairs created') {
                UI.showMainContent(false);
                return;
            }
            const selectedId = parseInt(selectedIdStr);
            localStorage.setItem('lastSelectedPairId', selectedId);
            const pairs = await DB.getAll(PAIRS_STORE);
            currentPair = pairs.find(p => p.id === selectedId);
            if (currentPair) {
                UI.showMainContent(true);
                $('#config-stock-a-label').text(`${currentPair.stockATicker} Initial Qty`);
                $('#config-stock-a-qty').val(currentPair.stockAInitialQty).prop('readonly', true);
                $('#config-stock-b-label').text(`${currentPair.stockBTicker} Initial Qty`);
                $('#config-stock-b-qty').val(currentPair.stockBInitialQty).prop('readonly', true);
                const trades = await DB.getTradesByPairId(currentPair.id);
                UI.renderTradeLog(trades);
                UI.renderNewTradeRow();
                UI.renderPerformance(trades);
            } else {
                UI.showMainContent(false);
            }
        },
        saveNewPair: async function() {
            const newPair = {
                pairName: $('#pair-name').val().trim().toUpperCase(),
                stockATicker: $('#stock-a-ticker').val().trim().toUpperCase(),
                stockBTicker: $('#stock-b-ticker').val().trim().toUpperCase(),
                stockAInitialQty: '0',
                stockBInitialQty: '0'
            };
            $('#pair-name').removeClass('is-invalid');
            const validationResult = await Helpers.validateNewPair(newPair);
            if (!validationResult.isValid) {
                UI.showToast('Validation Error', validationResult.error, true);
                if (validationResult.field === 'pair-name') {
                    $('#pair-name').addClass('is-invalid');
                }
                return;
            }
            const newId = await DB.add(PAIRS_STORE, newPair);
            newPair.id = newId;
            const addDemoData = $('#add-demo-data-checkbox').is(':checked');
            if (addDemoData) {
                newPair.stockAInitialQty = '100';
                newPair.stockBInitialQty = '100';
                await DB.put(PAIRS_STORE, newPair);
                const demoTrades = Helpers.generateDemoTrades(newPair);
                await DB.bulkAdd(TRADES_STORE, demoTrades);
            }
            $('#new-pair-form')[0].reset();
            bootstrap.Modal.getInstance($('#pair-config-modal')).hide();
            await this.loadPairs();
            $('#pair-selector').val(newId);
            await this.loadPairData();
            UI.showToast('Success', `Pair "${newPair.pairName}" created successfully.`);
        },
        saveNewTrade: async function() {
            const validationResult = await Helpers.validateNewTrade();
            if (!validationResult.isValid) {
                UI.showToast('Validation Error', validationResult.error, true);
                return;
            }
            await DB.add(TRADES_STORE, validationResult.trade);
            await this.loadPairData();
            UI.showToast('Success', 'Trade logged successfully.');
        },
        actionHandlers: {
            'clear-log': async function() {
                if (!currentPair) return;
                try {
                    await DB.clearTradesForPair(currentPair.id);
                    await App.loadPairData();
                    UI.showToast('Success', `All trades for "${currentPair.pairName}" have been cleared.`);
                } catch (error) {
                    UI.showToast('Error', 'Failed to clear trade log.', true);
                    console.error('Clear trade log error:', error);
                }
            },
            'clear-db': async function() {
                try {
                    await DB.clearAllData();
                    currentPair = null;
                    localStorage.clear();
                    $('#fractional-shares-switch').prop('checked', false);
                    allowFractionalShares = false;
                    await App.loadPairs();
                    UI.showToast('Success', 'All application data has been cleared.');
                } catch (error) {
                    UI.showToast('Error', 'Failed to clear the database.', true);
                    console.error('Clear database error:', error);
                }
            },
            'add-demo-data': async function() {
                if (!currentPair) return;
                try {
                    currentPair.stockAInitialQty = '100';
                    currentPair.stockBInitialQty = '100';
                    await DB.put(PAIRS_STORE, currentPair);
                    const demoTrades = Helpers.generateDemoTrades(currentPair);
                    await DB.bulkAdd(TRADES_STORE, demoTrades);
                    await App.loadPairData();
                    UI.showToast('Success', `Demo data added to "${currentPair.pairName}".`);
                } catch (error) {
                    UI.showToast('Error', 'Failed to add demo data.', true);
                    console.error('Add demo data error:', error);
                }
            },
            'delete-pair': async function() {
                if (!currentPair) return;
                try {
                    await DB.deletePairAndTrades(currentPair.id);
                    currentPair = null;
                    localStorage.removeItem('lastSelectedPairId');
                    await App.loadPairs();
                    UI.showToast('Success', 'Pair deleted successfully.');
                } catch (error) {
                    UI.showToast('Error', 'Failed to delete pair.', true);
                    console.error('Delete pair error:', error);
                }
            },
            'delete-trade': async function() {
                const tradeId = parseInt($('#confirm-action-modal').data('tradeId'));
                if (isNaN(tradeId)) return;
                try {
                    await DB.delete(TRADES_STORE, tradeId);
                    await App.loadPairData();
                    UI.showToast('Success', 'Trade deleted successfully.');
                } catch (error) {
                    UI.showToast('Error', 'Failed to delete trade.', true);
                    console.error('Delete trade error:', error);
                }
            },
        },
        handleConfirmAction: async function() {
            const action = $('#confirm-action-modal').data('action');
            confirmActionModal.hide();
            const handler = this.actionHandlers[action];
            if (handler) {
                await handler.call(this);
            }
        },
        confirmHistoricTradeUpdate: function() {
            return new Promise(resolve => {
                const modal = $('#confirm-action-modal');
                const confirmBtn = modal.find('#confirm-action-btn');
                modal.find('#confirm-action-modal-title').text('Confirm Trade Update');
                modal.find('#confirm-action-modal-body').html('<p>Are you sure you want to update the existing trade details?</p><p class="text-muted small">Updating an historic trade will change the Outcome and Performance metrics.</p>');
                confirmBtn.text('Confirm').removeClass('btn-danger').addClass('btn-primary');
                const onConfirm = () => {
                    cleanup();
                    resolve(true);
                };
                const onCancel = () => {
                    cleanup();
                    resolve(false);
                };
                const cleanup = () => {
                    confirmBtn.off('click', onConfirm);
                    modal.off('hidden.bs.modal', onCancel);
                    confirmActionModal.hide();
                };
                confirmBtn.one('click', onConfirm);
                modal.one('hidden.bs.modal', onCancel);
                confirmActionModal.show();
            });
        },
        handleTradeUpdate: async function(inputElement) {
            const $input = $(inputElement);
            const $row = $input.closest('tr');
            let tradeId, field;
            if ($row.hasClass('notes-row')) {
                tradeId = $row.data('notes-for-trade-id');
                field = $input.data('field');
            } else {
                const $cell = $input.closest('td');
                tradeId = $row.data('trade-id');
                field = $cell.data('field');
            }
            const newValue = $input.val();
            const trade = await DB.get(TRADES_STORE, tradeId);
            if (!trade || newValue == trade[field]) {
                return this.loadPairData();
            }
            const allTrades = await DB.getTradesByPairId(currentPair.id);
            const latestTradeId = allTrades.length > 0 ? allTrades[allTrades.length - 1].id : null;
            if (tradeId !== latestTradeId) {
                const confirmed = await this.confirmHistoricTradeUpdate();
                if (!confirmed) {
                    return this.loadPairData();
                }
            }
            const validationResult = await Helpers.validateTradeUpdate(trade, field, newValue);
            if (!validationResult.isValid) {
                UI.showToast('Validation Error', validationResult.error, true);
                return this.loadPairData();
            }
            trade[field] = validationResult.sanitizedValue;
            if (field === 'fromTicker') {
                trade.toTicker = (trade.fromTicker === currentPair.stockATicker) ? currentPair.stockBTicker : currentPair.stockATicker;
            }
            await DB.put(TRADES_STORE, trade);
            await this.loadPairData();
            UI.showToast('Success', 'Trade updated successfully.');
        },
        updateInitialQuantity: async function(inputElement) {
            const $input = $(inputElement);
            $input.prop('readonly', true);
            let newValue = $input.val();
            const stockId = $input.attr('id') === 'config-stock-a-qty' ? 'A' : 'B';
            const originalValue = stockId === 'A' ? currentPair.stockAInitialQty : currentPair.stockBInitialQty;
            if (newValue === '' || isNaN(parseFloat(newValue)) || parseFloat(newValue) < 0) {
                UI.showToast('Invalid Input', 'Initial quantity must be a non-negative number.', true);
                $input.val(originalValue);
                return;
            }
            if (!allowFractionalShares) {
                newValue = Math.floor(parseFloat(newValue)).toString();
            }
            if (newValue === originalValue) {
                return;
            }
            if (stockId === 'A') {
                currentPair.stockAInitialQty = newValue;
            } else {
                currentPair.stockBInitialQty = newValue;
            }
            try {
                await DB.put(PAIRS_STORE, currentPair);
                UI.showToast('Success', 'Initial quantity updated.');
                await this.loadPairData();
            } catch (error) {
                UI.showToast('Database Error', 'Could not save changes.', true);
                console.error("Failed to update pair:", error);
                $input.val(originalValue);
            }
        },
        exportToCSV: async function() {
            if (!currentPair) return;
            const trades = await DB.getTradesByPairId(currentPair.id);
            if (trades.length === 0) {
                UI.showToast('Export Failed', 'No trades to export for this pair.', true);
                return;
            }
            let csvContent = "data:text/csv;charset=utf-8,";
            const headers = ["Date", "From Ticker", "From Qty", "From Price", "To Ticker", "To Qty", "To Price", "Notes", "Completed"];
            csvContent += headers.join(",") + "\r\n";
            trades.forEach(trade => {
                const toQty = (parseFloat(trade.fromPrice) / parseFloat(trade.toPrice)) * parseFloat(trade.swapQty);
                const row = [
                    trade.date,
                    trade.fromTicker,
                    trade.swapQty,
                    trade.fromPrice,
                    trade.toTicker,
                    isFinite(toQty) ? toQty.toFixed(8) : '0',
                    trade.toPrice,
                    `"${trade.notes || ''}"`,
                    trade.isComplete || false
                ];
                csvContent += row.join(",") + "\r\n";
            });
            const filename = Helpers.generateExportFilename(currentPair.pairName);
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", filename);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            UI.showToast('Success', 'Trade log exported.');
        },
        importFromCSV: function(event) {
            if (!currentPair) {
                UI.showToast('Import Failed', 'Please select a pair before importing.', true);
                return;
            }
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                const text = e.target.result;
                const rows = text.split('\n').slice(1);
                const tradesToImport = [];
                for (const row of rows) {
                    if (row.trim() === '') continue;
                    const cols = row.split(',');
                    if (cols.length < 9) {
                        UI.showToast('Import Error', `Skipping invalid row: ${row}`, true);
                        continue;
                    }
                    const trade = {
                        pairId: currentPair.id,
                        date: cols[0],
                        fromTicker: cols[1],
                        swapQty: cols[2],
                        fromPrice: cols[3],
                        toTicker: cols[4],
                        toPrice: cols[6],
                        notes: (cols[7] || '').replace(/"/g, ''),
                        isComplete: (cols[8] || '').trim() === 'true'
                    };
                    tradesToImport.push(trade);
                }
                if (tradesToImport.length > 0) {
                    try {
                        await DB.bulkAdd(TRADES_STORE, tradesToImport);
                        await this.loadPairData();
                        UI.showToast('Success', `${tradesToImport.length} trades imported successfully.`);
                    } catch (error) {
                        UI.showToast('Import Failed', 'An error occurred during the database transaction.', true);
                    }
                }
                $('#import-csv-input').val('');
            };
            reader.readAsText(file);
        },
        toggleFractionalShares: function() {
            allowFractionalShares = $('#fractional-shares-switch').is(':checked');
            localStorage.setItem('allowFractionalShares', allowFractionalShares);
            UI.updateNumberInputs();
            if (currentPair) {
                this.loadPairData();
            }
        },
        bindPairEvents: function() {
            $('#save-pair-btn').on('click', this.saveNewPair.bind(this));
            $('#pair-selector').on('change', this.loadPairData.bind(this));
            $('#delete-pair-btn').on('click', function() {
                if (!currentPair) {
                    UI.showToast('Action Failed', 'No pair is currently selected to delete.', true);
                    return;
                }
                $('#confirm-action-modal-title').text('Confirm Pair Deletion');
                $('#confirm-action-modal-body').html(`<p>Are you sure you want to delete the <strong>${currentPair.pairName}</strong> pair and all of its associated trades?</p><p class="text-danger">This action is permanent and cannot be undone.</p>`);
                $('#confirm-action-modal').data('action', 'delete-pair');
                confirmActionModal.show();
            });
            $('#pair-configuration').on('dblclick', 'input[type="number"]', function() {
                $(this).prop('readonly', false).focus().select();
            });
            $('#pair-configuration').on('blur', 'input[type="number"]', (e) => {
                if (!$(e.currentTarget).prop('readonly')) {
                    this.updateInitialQuantity(e.currentTarget);
                }
            });
            $('#pair-configuration').on('keydown', 'input[type="number"]', (e) => {
                if (e.key === 'Enter') {
                    $(e.currentTarget).blur();
                }
            });
        },
        bindTradeLogEvents: function() {
            $(document).on('click', '#date-header', () => {
                UI.dateSortOrder = UI.dateSortOrder === 'asc' ? 'desc' : 'asc';
                this.loadPairData();
            });
            const tradeLogBody = $('#trade-log-body');
            tradeLogBody.on('click', '.notes-icon-btn', function() {
                const $row = $(this).closest('tr');
                const tradeId = $row.data('trade-id');
                $(`tr[data-notes-for-trade-id="${tradeId}"]`).toggleClass('d-none');
            });
            tradeLogBody.on('dblclick', 'textarea.notes-editor', function() {
                const $textarea = $(this);
                $textarea.prop('readonly', false).focus();
                this.selectionStart = this.selectionEnd = this.value.length;
                const $cell = $textarea.closest('td');
                $cell.find('.edit-note-helper').remove();
                $cell.append('<div class="form-text mt-1 edit-note-helper">Press Enter to save, or Esc to cancel.</div>');
            });
            tradeLogBody.on('blur', 'textarea.notes-editor', (e) => {
                if (!$(e.currentTarget).prop('readonly')) {
                    App.handleTradeUpdate(e.currentTarget);
                }
            });
            tradeLogBody.on('keydown', 'textarea.notes-editor', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    $(e.currentTarget).blur();
                }
                if (e.key === 'Escape') {
                    App.loadPairData();
                }
            });
            tradeLogBody.on('dblclick', '.editable-cell', async function() {
                const $cell = $(this);
                if ($cell.find('input, select').length > 0) return;
                const $row = $cell.closest('tr');
                const tradeId = $row.data('trade-id');
                const field = $cell.data('field');
                const trade = await DB.get(TRADES_STORE, tradeId);
                if (!trade) return;
                const currentValue = trade[field];
                const inputHtml = UI.createCellEditor(field, currentValue);
                $cell.html(inputHtml);
                const $input = $cell.find('input, select');
                $input.focus().select();
                $input.on('blur', () => App.handleTradeUpdate($input[0]));
                $input.on('keydown', (e) => {
                    if (e.key === 'Enter') $input.blur();
                    if (e.key === 'Escape') App.loadPairData();
                });
            });
            tradeLogBody.on('click', '.delete-trade-btn', function() {
                const tradeId = $(this).data('trade-id');
                $('#confirm-action-modal-title').text('Confirm Trade Deletion');
                $('#confirm-action-modal-body').html('<p>Are you sure you want to delete this trade? This action is permanent and cannot be undone.</p>');
                $('#confirm-action-modal').data('action', 'delete-trade').data('tradeId', tradeId);
                confirmActionModal.show();
            });
            tradeLogBody.on('change', '.swap-back-toggle', async function() {
                const checkbox = this;
                const tradeId = $(checkbox).data('trade-id');
                const isNowComplete = $(checkbox).is(':checked');
                try {
                    const trade = await DB.get(TRADES_STORE, tradeId);
                    if (trade) {
                        trade.isComplete = isNowComplete;
                        await DB.put(TRADES_STORE, trade);
                        await App.loadPairData();
                        const toastMessage = isNowComplete ? 'Trade marked as complete.' : 'Trade status reset to incomplete.';
                        UI.showToast('Success', toastMessage);
                    }
                } catch (error) {
                    console.error('Failed to update trade status:', error);
                    UI.showToast('Error', 'Could not update trade status.', true);
                    $(checkbox).prop('checked', !isNowComplete);
                }
            });
        },
        bindNewTradeRowEvents: function() {
            const newTradeRow = $('#new-trade-body');
            newTradeRow.on('click', '#save-trade-btn', this.saveNewTrade.bind(this));
            newTradeRow.on('change', '#new-from-ticker', UI.updateToTicker.bind(UI));
            newTradeRow.on('input', '#new-from-price, #new-to-price, #new-swap-qty', UI.updateCalculatedFields.bind(UI));
            newTradeRow.on('dblclick', '#new-to-qty', function() {
                $(this).prop('readonly', false).removeClass('bg-body-secondary').addClass('bg-body');
                UI.isToQtyCalculated = false;
            });
        },
        bindModalAndConfirmationEvents: function() {
            $('#confirm-action-btn').on('click', this.handleConfirmAction.bind(this));
        },
        bindSettingsAndDataManagementEvents: function() {
            $('#export-csv-btn').on('click', this.exportToCSV.bind(this));
            $('#import-csv-input').on('change', this.importFromCSV.bind(this));
            $('#fractional-shares-switch').on('change', this.toggleFractionalShares.bind(this));
            $('#data-management-collapse, #settings-collapse').on('shown.bs.collapse hidden.bs.collapse', () => {
                localStorage.setItem('isDataManagementExpanded', $('#data-management-collapse').hasClass('show'));
                localStorage.setItem('isSettingsExpanded', $('#settings-collapse').hasClass('show'));
            });
            $('#add-demo-data-btn').on('click', function() {
                if (!currentPair) return;
                $('#confirm-action-modal-title').text('Add Demo Data');
                $('#confirm-action-modal-body').html(`<p>Are you sure you want to add demo trades to the <strong>${currentPair.pairName}</strong> pair?</p><p class="text-muted">This will also reset the initial quantities for this pair to 100.</p>`);
                $('#confirm-action-modal').data('action', 'add-demo-data');
                confirmActionModal.show();
            });
            $('#clear-log-btn').on('click', function() {
                if (currentPair) {
                    $('#confirm-action-modal-title').text('Clear Trade Log');
                    $('#confirm-action-modal-body').html(`<p>Are you sure you want to clear all trades for the <strong>${currentPair.pairName}</strong> pair?</p><p class="text-danger">This action cannot be undone.</p>`);
                    $('#confirm-action-modal').data('action', 'clear-log');
                    confirmActionModal.show();
                }
            });
            $('#clear-db-btn').on('click', function() {
                $('#confirm-action-modal-title').text('Clear Entire Database');
                $('#confirm-action-modal-body').html(`<p>Are you sure you want to delete <strong>ALL</strong> pairs and trades from the database?</p><p class="text-danger">This action is permanent and cannot be undone.</p>`);
                $('#confirm-action-modal').data('action', 'clear-db');
                confirmActionModal.show();
            });
        },
        bindEvents: function() {
            this.bindPairEvents();
            this.bindTradeLogEvents();
            this.bindNewTradeRowEvents();
            this.bindModalAndConfirmationEvents();
            this.bindSettingsAndDataManagementEvents();
        }
    };

    // --- INITIALIZE APP ---
    App.init();
});
```You are right, the `SyntaxError` is a blocking issue. My apologies for the repeated problems. The error is happening because the `app.js` file has become corrupted with duplicate code from previous, partially-applied updates.

The most reliable way to fix this is to replace the entire content of `assets/js/app.js` with a clean, corrected version. This will resolve the syntax error and ensure the application runs as expected.

### File Update

Please replace the entire content of `z:\trading_git\httpdocs\trading\tools\pair-trade-tracker\assets\js\app.js` with the following code. This is a complete, corrected version of the file.

```javascript
$(document).ready(function() {
    'use strict';

    const DB_NAME = 'PairTradeTrackerDB';
    const DB_VERSION = 1;
    const PAIRS_STORE = 'pairs';
    const TRADES_STORE = 'trades';

    let db;
    let currentPair = null;
    let confirmActionModal;
    let allowFractionalShares = false;

    // --- DATABASE MANAGEMENT ---
    const DB = {
        init: function() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (event) => {
                    const dbInstance = event.target.result;
                    if (!dbInstance.objectStoreNames.contains(PAIRS_STORE)) {
                        dbInstance.createObjectStore(PAIRS_STORE, { keyPath: 'id', autoIncrement: true });
                    }
                    if (!dbInstance.objectStoreNames.contains(TRADES_STORE)) {
                        const tradesStore = dbInstance.createObjectStore(TRADES_STORE, { keyPath: 'id', autoIncrement: true });
                        tradesStore.createIndex('pairId', 'pairId', { unique: false });
                    }
                };
                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve(db);
                };
                request.onerror = (event) => {
                    console.error('Database error:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        },
        add: function(storeName, item) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.add(item);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        },
        getAll: function(storeName) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        },
        get: function(storeName, key) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        },
        put: function(storeName, item) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(item);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        },
        delete: function(storeName, key) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(key);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        },
        deletePairAndTrades: function(pairId) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([TRADES_STORE, PAIRS_STORE], 'readwrite');
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
                const tradesStore = transaction.objectStore(TRADES_STORE);
                const pairsStore = transaction.objectStore(PAIRS_STORE);
                const tradesIndex = tradesStore.index('pairId');
                const cursorRequest = tradesIndex.openCursor(IDBKeyRange.only(pairId));
                cursorRequest.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        cursor.delete();
                        cursor.continue();
                    } else {
                        pairsStore.delete(pairId);
                    }
                };
            });
        },
        clearTradesForPair: function(pairId) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([TRADES_STORE], 'readwrite');
                const store = transaction.objectStore(TRADES_STORE);
                const index = store.index('pairId');
                const request = index.openCursor(IDBKeyRange.only(pairId));
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        cursor.delete();
                        cursor.continue();
                    }
                };
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
            });
        },
        clearAllData: function() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([PAIRS_STORE, TRADES_STORE], 'readwrite');
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
                const pairsStore = transaction.objectStore(PAIRS_STORE);
                const tradesStore = transaction.objectStore(TRADES_STORE);
                pairsStore.clear();
                tradesStore.clear();
            });
        },
        getTradesByPairId: function(pairId) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([TRADES_STORE], 'readonly');
                const store = transaction.objectStore(TRADES_STORE);
                const index = store.index('pairId');
                const request = index.getAll(pairId);
                request.onsuccess = () => {
                    const sortedTrades = [...request.result].sort((a, b) => new Date(a.date) - new Date(b.date));
                    resolve(sortedTrades);
                };
                request.onerror = () => reject(request.error);
            });
        },
        bulkAdd: function(storeName, items) {
            return new Promise((resolve, reject) => {
                if (items.length === 0) {
                    return resolve();
                }
                const transaction = db.transaction([storeName], 'readwrite');
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
                const store = transaction.objectStore(storeName);
                items.forEach(item => store.add(item));
            });
        }
    };

    // --- UI MANAGEMENT & RENDERERS ---
    const UI = {
        dateSortOrder: 'asc',
        isToQtyCalculated: true,
        showMainContent: function(shouldShow) {
            if (shouldShow) {
                $('#welcome-message').addClass('d-none');
                $('#main-content').removeClass('d-none');
                $('#pair-configuration').removeClass('d-none');
                $('#delete-pair-btn').prop('disabled', false);
            } else {
                $('#welcome-message').removeClass('d-none');
                $('#main-content').addClass('d-none');
                $('#pair-configuration').addClass('d-none');
                $('#delete-pair-btn').prop('disabled', true);
            }
        },
        populatePairSelector: function(pairs) {
            const selector = $('#pair-selector');
            selector.empty();
            if (pairs.length === 0) {
                this.showMainContent(false);
                selector.append('<option>No pairs created</option>');
            } else {
                this.showMainContent(true);
                pairs.forEach(pair => {
                    selector.append(`<option value="${pair.id}">${pair.pairName}</option>`);
                });
            }
        },
        renderTradeLog: function(trades) {
            const tbody = $('#trade-log-body');
            tbody.empty();
            if (!currentPair) return;

            const NUM_COLUMNS = 12;
            const iconName = this.dateSortOrder === 'asc' ? 'arrow_drop_up' : 'arrow_drop_down';
            $('#date-sort-icon').html(iconName).addClass('material-symbols-outlined icon-inline-sm sort-icon');
            $('.stock-a-qty-header').text(`${currentPair.stockATicker}`);
            $('.stock-b-qty-header').text(`${currentPair.stockBTicker}`);

            const holdingsHistory = Helpers.calculateAllHoldings(trades);
            let combinedData = trades.map((trade, index) => ({
                trade: trade,
                holdings: holdingsHistory[index]
            }));

            combinedData.sort((a, b) => {
                const dateA = new Date(a.trade.date);
                const dateB = new Date(b.trade.date);
                return this.dateSortOrder === 'asc' ? dateA - dateB : dateB - dateA;
            });

            combinedData.forEach(data => {
                const { trade, holdings } = data;
                const swapQty = parseFloat(trade.swapQty);
                const ratio = parseFloat(trade.fromPrice) / parseFloat(trade.toPrice);
                const displayRatio = Helpers.calculatePairRatio(parseFloat(trade.fromPrice), parseFloat(trade.toPrice), trade.fromTicker);
                const qtyDisplayFormat = { minimumFractionDigits: 0, maximumFractionDigits: allowFractionalShares ? 4 : 0 };
                const swapQtyDisplay = swapQty.toLocaleString(undefined, qtyDisplayFormat);
                const toQty = swapQty * ratio;
                const toQtyDisplay = toQty.toLocaleString(undefined, qtyDisplayFormat);
                const editableClass = 'editable-cell';
                const notesIcon = trade.notes ? 'description' : 'note_add';
                const isComplete = trade.isComplete || false;
                const toggleTitle = isComplete ? 'Reset trade to incomplete' : 'Mark trade as complete';

                const row = `
                    <tr data-trade-id="${trade.id}">
                        <td class="${editableClass}" data-field="date">${Helpers.formatDateForDisplay(trade.date)}</td>
                        <td class="${editableClass}" data-field="fromTicker">${trade.fromTicker}</td>
                        <td class="${editableClass}" data-field="swapQty">${swapQtyDisplay}</td>
                        <td class="${editableClass}" data-field="fromPrice">$${parseFloat(trade.fromPrice).toFixed(2)}</td>
                        <td>${trade.toTicker}</td>
                        <td>${toQtyDisplay}</td>
                        <td class="${editableClass}" data-field="toPrice">$${parseFloat(trade.toPrice).toFixed(2)}</td>
                        <td>${displayRatio !== null ? displayRatio.toFixed(4) : 'N/A'}</td>
                        <td>${holdings.qtyA.toLocaleString(undefined, qtyDisplayFormat)}</td>
                        <td>${holdings.qtyB.toLocaleString(undefined, qtyDisplayFormat)}</td>
                        <td>
                            <button class="btn btn-sm notes-icon-btn" title="View/Edit Notes">
                                <span class="material-symbols-outlined">${notesIcon}</span>
                            </button>
                        </td>
                        <td>
                            <button class="btn btn-sm btn-outline-danger delete-trade-btn" data-trade-id="${trade.id}" title="Delete Trade" ${isComplete ? 'disabled' : ''}>
                                <span class="material-symbols-outlined">delete</span>
                            </button>
                            <div class="form-check d-inline-block align-middle ms-2" 
                                 data-bs-toggle="tooltip" 
                                 data-bs-placement="top" 
                                 title="${toggleTitle}">
                                <input class="form-check-input swap-back-toggle" type="checkbox" data-trade-id="${trade.id}" ${isComplete ? 'checked' : ''}>
                            </div>
                        </td>
                    </tr>`;

                const notesContent = `<textarea class="form-control form-control-sm notes-editor" data-field="notes" rows="2" placeholder="Double-click to add/edit notes..." readonly>${trade.notes || ''}</textarea>`;
                const notesRow = `<tr class="notes-row d-none" data-notes-for-trade-id="${trade.id}"><td colspan="${NUM_COLUMNS}">${notesContent}</td></tr>`;

                tbody.append(row);
                tbody.append(notesRow);
            });
        },
        renderNewTradeRow: function() {
            const newTradeBody = $('#new-trade-body');
            newTradeBody.empty();
            if (!currentPair) return;

            const fromOptions = `<option value="${currentPair.stockATicker}">${currentPair.stockATicker}</option><option value="${currentPair.stockBTicker}">${currentPair.stockBTicker}</option>`;
            const newTradeRow = `
                <tr id="new-trade-row">
                    <td><input type="date" id="new-date" class="form-control form-control-sm"></td>
                    <td><select id="new-from-ticker" class="form-select form-select-sm trade-select">${fromOptions}</select></td>
                    <td><input type="number" id="new-swap-qty" class="form-control form-control-sm trade-input" min="0" step="any"></td>
                    <td><input type="number" id="new-from-price" class="form-control form-control-sm trade-input" min="0" step="0.01"></td>
                    <td><input type="text" id="new-to-ticker" class="form-control form-control-sm" disabled></td>
                    <td><input type="text" id="new-to-qty" class="form-control form-control-sm trade-input bg-body-secondary" readonly></td>
                    <td><input type="number" id="new-to-price" class="form-control form-control-sm trade-input" min="0" step="0.01"></td>
                    <td><input type="text" id="new-ratio" class="form-control form-control-sm" disabled></td>
                    <td><textarea id="new-notes" class="form-control form-control-sm" rows="1" placeholder="add note here"></textarea></td>
                    <td><button id="save-trade-btn" class="btn btn-sm btn-success">Save</button></td>
                </tr>`;
            newTradeBody.append(newTradeRow);
            $('#new-date').val(new Date().toISOString().split('T')[0]);
            this.updateToTicker();
            this.updateNumberInputs();
            this.isToQtyCalculated = true;
            this.initializeTooltips();
        },
        renderPerformance: function(trades) {
            const metrics = Helpers.getPerformanceMetrics(trades);
            if (!metrics) {
                $('#initial-state').html('<p class="card-text text-muted">Configure a pair and add a trade to see starting values.</p>');
                $('#current-state').html('<p class="card-text text-muted">No trades logged yet.</p>');
                $('#performance-metrics').html('<p class="card-text text-muted">Awaiting trade data for calculations.</p>');
                return;
            }
            const qtyDisplayFormat = { minimumFractionDigits: 0, maximumFractionDigits: allowFractionalShares ? 4 : 0 };
            $('#initial-state').html(`
                <dl class="row mb-0">
                    <dt class="col-sm-7">${metrics.initial.qtyA.toLocaleString(undefined, qtyDisplayFormat)} ${currentPair.stockATicker}</dt>
                    <dd class="col-sm-5 text-end">$${metrics.initial.valueA.toFixed(2)}</dd>
                    <dt class="col-sm-7">${metrics.initial.qtyB.toLocaleString(undefined, qtyDisplayFormat)} ${currentPair.stockBTicker}</dt>
                    <dd class="col-sm-5 text-end">$${metrics.initial.valueB.toFixed(2)}</dd>
                    <dt class="col-sm-7 border-top pt-2 mt-1">Total Initial Value</dt>
                    <dd class="col-sm-5 text-end border-top pt-2 mt-1"><strong>$${metrics.initial.totalValue.toFixed(2)}</strong></dd>
                </dl>`);
            $('#current-state').html(`
                <dl class="row mb-0">
                    <dt class="col-sm-7">${metrics.current.qtyA.toLocaleString(undefined, qtyDisplayFormat)} ${currentPair.stockATicker}</dt>
                    <dd class="col-sm-5 text-end">$${metrics.current.valueA.toFixed(2)}</dd>
                    <dt class="col-sm-7">${metrics.current.qtyB.toLocaleString(undefined, qtyDisplayFormat)} ${currentPair.stockBTicker}</dt>
                    <dd class="col-sm-5 text-end">$${metrics.current.valueB.toFixed(2)}</dd>
                    <dt class="col-sm-7 border-top pt-2 mt-1">Total Current Value</dt>
                    <dd class="col-sm-5 text-end border-top pt-2 mt-1"><strong>$${metrics.current.totalValue.toFixed(2)}</strong></dd>
                </dl>`);
            const plClass = metrics.performance.totalPL >= 0 ? 'text-success' : 'text-danger';
            $('#performance-metrics').html(`
                <dl class="row mb-0">
                    <dt class="col-sm-8">Total P/L</dt>
                    <dd class="col-sm-4 text-end ${plClass}"><strong>$${metrics.performance.totalPL.toFixed(2)}</strong></dd>
                    <dt class="col-sm-8">Percentage Gain/Loss</dt>
                    <dd class="col-sm-4 text-end ${plClass}"><strong>${metrics.performance.percentageGain.toFixed(2)}%</strong></dd>
                </dl>`);
        },
        updateNumberInputs: function() {
            const step = allowFractionalShares ? 'any' : '1';
            $('#config-stock-a-qty, #config-stock-b-qty, #new-swap-qty').attr('step', step);
        },
        updateToTicker: function() {
            const fromTicker = $('#new-from-ticker').val();
            const toTicker = (fromTicker === currentPair.stockATicker) ? currentPair.stockBTicker : currentPair.stockATicker;
            $('#new-to-ticker').val(toTicker);
        },
        updateCalculatedFields: function() {
            const fromPrice = parseFloat($('#new-from-price').val());
            const swapQty = parseFloat($('#new-swap-qty').val());
            const toQtyInput = $('#new-to-qty');
            const toPriceInput = $('#new-to-price');
            const ratioInput = $('#new-ratio');
            const qtyDisplayFormat = { minimumFractionDigits: allowFractionalShares ? 4 : 0, maximumFractionDigits: allowFractionalShares ? 4 : 0 };

            if (this.isToQtyCalculated) {
                const toPrice = parseFloat(toPriceInput.val());
                if (!isNaN(fromPrice) && fromPrice > 0 && !isNaN(swapQty) && swapQty > 0 && !isNaN(toPrice) && toPrice > 0) {
                    const calculatedToQty = (fromPrice * swapQty) / toPrice;
                    toQtyInput.val(calculatedToQty.toLocaleString(undefined, qtyDisplayFormat));
                } else {
                    toQtyInput.val('');
                }
            }
            const finalToPrice = parseFloat(toPriceInput.val());
            if (!isNaN(fromPrice) && fromPrice > 0 && !isNaN(finalToPrice) && finalToPrice > 0) {
                const fromTicker = $('#new-from-ticker').val();
                const displayRatio = Helpers.calculatePairRatio(fromPrice, finalToPrice, fromTicker);
                ratioInput.val(displayRatio !== null ? displayRatio.toFixed(4) : '');
            } else {
                ratioInput.val('');
            }
        },
        initializeTooltips: function() {
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.map(function(tooltipTriggerEl) {
                const existingTooltip = bootstrap.Tooltip.getInstance(tooltipTriggerEl);
                if (existingTooltip) {
                    existingTooltip.dispose();
                }
                return new bootstrap.Tooltip(tooltipTriggerEl);
            });
        },
        showToast: function(title, message, isError = false) {
            $('#toast-title').text(title);
            $('#toast-body').text(message);
            $('#app-toast').attr('data-toast-type', isError ? 'error' : 'success');
            const appToast = new bootstrap.Toast(document.getElementById('app-toast'));
            appToast.show();
        },
        validateRow: function() {
            let isValid = true;
            const fields = ['#new-date', '#new-swap-qty', '#new-from-price', '#new-to-price'];
            fields.forEach(fieldId => {
                const field = $(fieldId);
                let isFieldValid = true;
                if (field.attr('type') === 'number') {
                    isFieldValid = field.val() && parseFloat(field.val()) > 0;
                } else {
                    isFieldValid = !!field.val();
                }
                if (!isFieldValid) {
                    field.addClass('is-invalid');
                    isValid = false;
                } else {
                    field.removeClass('is-invalid');
                }
            });
            return isValid;
        },
        createCellEditor: function(field, currentValue) {
            if (field === 'fromTicker') {
                const toTicker = (currentValue === currentPair.stockATicker) ? currentPair.stockBTicker : currentPair.stockATicker;
                return `<select class="form-select form-select-sm"><option value="${currentValue}" selected>${currentValue}</option><option value="${toTicker}">${toTicker}</option></select>`;
            }
            if (field === 'date') {
                return `<input type="date" class="form-control form-control-sm" value="${currentValue}">`;
            }
            const step = field === 'swapQty' ? (allowFractionalShares ? 'any' : '1') : '0.01';
            return `<input type="number" class="form-control form-control-sm trade-input" value="${currentValue}" step="${step}">`;
        },
        init: function() {
            confirmActionModal = new bootstrap.Modal(document.getElementById('confirm-action-modal'));
            if (localStorage.getItem('isDataManagementExpanded') === 'true') {
                new bootstrap.Collapse('#data-management-collapse', { toggle: false }).show();
            }
            if (localStorage.getItem('isSettingsExpanded') === 'true') {
                new bootstrap.Collapse('#settings-collapse', { toggle: false }).show();
            }
        }
    };

    // --- HELPERS ---
    const Helpers = {
        calculatePairRatio: function(price1, price2, ticker1) {
            if (!currentPair || !currentPair.stockATicker) return null;
            const { stockATicker } = currentPair;
            let priceA, priceB;
            if (ticker1 === stockATicker) {
                priceA = price1;
                priceB = price2;
            } else {
                priceA = price2;
                priceB = price1;
            }
            if (priceA > 0 && priceB > 0) return priceA / priceB;
            return null;
        },
        formatDateForDisplay: function(dateString) {
            if (!dateString || typeof dateString !== 'string') return 'N/A';
            const parts = dateString.split('-');
            if (parts.length !== 3) return dateString;
            const year = parseInt(parts[0], 10);
            const monthIndex = parseInt(parts[1], 10) - 1;
            const day = parseInt(parts[2], 10);
            const date = new Date(Date.UTC(year, monthIndex, day));
            if (isNaN(date.getTime())) return dateString;
            const monthNames = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
            return `${String(date.getUTCDate()).padStart(2, '0')}-${monthNames[date.getUTCMonth()]}-${date.getUTCFullYear()}`;
        },
        calculateAllHoldings: function(trades) {
            const holdingsHistory = [];
            if (!currentPair) return holdingsHistory;
            let qtyA = parseFloat(currentPair.stockAInitialQty);
            let qtyB = parseFloat(currentPair.stockBInitialQty);
            trades.forEach(trade => {
                const ratio = parseFloat(trade.fromPrice) / parseFloat(trade.toPrice);
                const swapQty = parseFloat(trade.swapQty);
                if (trade.fromTicker === currentPair.stockATicker) {
                    qtyA -= swapQty;
                    qtyB += (swapQty * ratio);
                } else {
                    qtyB -= swapQty;
                    qtyA += (swapQty * ratio);
                }
                let currentQtyA = qtyA;
                let currentQtyB = qtyB;
                if (!allowFractionalShares) {
                    currentQtyA = Math.floor(qtyA);
                    currentQtyB = Math.floor(qtyB);
                }
                holdingsHistory.push({ qtyA: currentQtyA, qtyB: currentQtyB });
                qtyA = currentQtyA;
                qtyB = currentQtyB;
            });
            return holdingsHistory;
        },
        calculateHoldings: function(trades) {
            if (!currentPair) return { qtyA: 0, qtyB: 0 };
            if (trades.length === 0) {
                return { qtyA: parseFloat(currentPair.stockAInitialQty), qtyB: parseFloat(currentPair.stockBInitialQty) };
            }
            const history = this.calculateAllHoldings(trades);
            return history[history.length - 1];
        },
        getPerformanceMetrics: function(trades) {
            if (!currentPair || trades.length === 0) return null;
            const initialQtyA = parseFloat(currentPair.stockAInitialQty);
            const initialQtyB = parseFloat(currentPair.stockBInitialQty);
            const firstTrade = trades[0];
            let initialPriceA, initialPriceB;
            if (firstTrade.fromTicker === currentPair.stockATicker) {
                initialPriceA = parseFloat(firstTrade.fromPrice);
                initialPriceB = parseFloat(firstTrade.toPrice);
            } else {
                initialPriceB = parseFloat(firstTrade.fromPrice);
                initialPriceA = parseFloat(firstTrade.toPrice);
            }
            const initialValueA = initialQtyA * initialPriceA;
            const initialValueB = initialQtyB * initialPriceB;
            const initialTotalValue = initialValueA + initialValueB;
            const finalHoldings = this.calculateHoldings(trades);
            const lastTrade = trades[trades.length - 1];
            let lastPriceA, lastPriceB;
            if (lastTrade.fromTicker === currentPair.stockATicker) {
                lastPriceA = parseFloat(lastTrade.fromPrice);
                lastPriceB = parseFloat(lastTrade.toPrice);
            } else {
                lastPriceB = parseFloat(lastTrade.fromPrice);
                lastPriceA = parseFloat(lastTrade.toPrice);
            }
            const currentValueA = finalHoldings.qtyA * lastPriceA;
            const currentValueB = finalHoldings.qtyB * lastPriceB;
            const currentTotalValue = currentValueA + currentValueB;
            const totalPL = currentTotalValue - initialTotalValue;
            const percentageGain = initialTotalValue > 0 ? (totalPL / initialTotalValue) * 100 : 0;
            return {
                initial: { qtyA: initialQtyA, qtyB: initialQtyB, valueA: initialValueA, valueB: initialValueB, totalValue: initialTotalValue },
                current: { qtyA: finalHoldings.qtyA, qtyB: finalHoldings.qtyB, valueA: currentValueA, valueB: currentValueB, totalValue: currentTotalValue },
                performance: { totalPL: totalPL, percentageGain: percentageGain }
            };
        },
        validateTradeUpdate: async function(trade, field, newValue) {
            let sanitizedValue = newValue;
            if (field !== 'notes') {
                if (field === 'fromPrice' || field === 'toPrice') {
                    sanitizedValue = sanitizedValue.replace('$', '');
                }
                if (field === 'swapQty' || field === 'fromPrice' || field === 'toPrice') {
                    if (isNaN(parseFloat(sanitizedValue)) || parseFloat(sanitizedValue) <= 0) {
                        return { isValid: false, error: 'Price and quantity must be positive numbers.' };
                    }
                }
                const allTrades = await DB.getTradesByPairId(currentPair.id);
                const tradeIndex = allTrades.findIndex(t => t.id === trade.id);
                if (tradeIndex === -1) {
                    return { isValid: false, error: 'Could not find the trade to validate against.' };
                }
                const tradesBefore = allTrades.slice(0, tradeIndex);
                const holdingsBefore = this.calculateHoldings(tradesBefore);
                const fromTicker = field === 'fromTicker' ? sanitizedValue : trade.fromTicker;
                const swapQty = field === 'swapQty' ? parseFloat(sanitizedValue) : parseFloat(trade.swapQty);
                if (fromTicker === currentPair.stockATicker && swapQty > holdingsBefore.qtyA) {
                    return { isValid: false, error: `Swap quantity exceeds holdings for ${fromTicker} at that time.` };
                }
                if (fromTicker === currentPair.stockBTicker && swapQty > holdingsBefore.qtyB) {
                    return { isValid: false, error: `Swap quantity exceeds holdings for ${fromTicker} at that time.` };
                }
            }
            return { isValid: true, sanitizedValue: sanitizedValue };
        },
        validateNewPair: async function(newPair) {
            if (!newPair.pairName || !newPair.stockATicker || !newPair.stockBTicker) {
                return { isValid: false, error: 'All fields are required to create a pair.', field: 'general' };
            }
            const existingPairs = await DB.getAll(PAIRS_STORE);
            if (existingPairs.some(pair => pair.pairName === newPair.pairName)) {
                return { isValid: false, error: `A pair named "${newPair.pairName}" already exists. Please choose a unique name.`, field: 'pair-name' };
            }
            return { isValid: true };
        },
        generateExportFilename: function(pairName) {
            const now = new Date();
            const year = now.getFullYear().toString().slice(-2);
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const dateStr = `${year}${month}${day}`;
            const safePairName = pairName.replace(/\//g, '-');
            return `${dateStr}--${safePairName}-SWAP-DB.csv`;
        },
        generateDemoTrades: function(pair) {
            const trades = [];
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 10);
            for (let i = 0; i < 8; i++) {
                const tradeDate = new Date(startDate);
                tradeDate.setDate(tradeDate.getDate() + i);
                const fromTicker = (i % 2 === 0) ? pair.stockATicker : pair.stockBTicker;
                const toTicker = (i % 2 === 0) ? pair.stockBTicker : pair.stockATicker;
                const swapQty = (Math.random() * 9 + 1).toFixed(allowFractionalShares ? 4 : 0);
                const fromPrice = (80 + Math.random() * 40).toFixed(2);
                const toPrice = (80 + Math.random() * 40).toFixed(2);
                trades.push({
                    pairId: pair.id,
                    date: tradeDate.toISOString().split('T')[0],
                    fromTicker, toTicker, swapQty, fromPrice, toPrice,
                    notes: `Demo trade ${i + 1}`,
                    isComplete: (i < 4)
                });
            }
            return trades;
        },
        validateNewTrade: async function() {
            if (!UI.validateRow()) {
                return { isValid: false, error: 'Please fill all required fields with valid positive numbers.' };
            }
            const allTrades = await DB.getTradesByPairId(currentPair.id);
            const holdingsBefore = this.calculateHoldings(allTrades);
            const fromTicker = $('#new-from-ticker').val();
            const newSwapQty = parseFloat($('#new-swap-qty').val());
            const qtyDisplayFormat = { minimumFractionDigits: 0, maximumFractionDigits: allowFractionalShares ? 4 : 0 };
            if (fromTicker === currentPair.stockATicker && newSwapQty > holdingsBefore.qtyA) {
                $('#new-swap-qty').addClass('is-invalid');
                return { isValid: false, error: `Swap quantity (${newSwapQty.toLocaleString(undefined, qtyDisplayFormat)}) cannot exceed current holding of ${currentPair.stockATicker} (${holdingsBefore.qtyA.toLocaleString(undefined, qtyDisplayFormat)}).` };
            }
            if (fromTicker === currentPair.stockBTicker && newSwapQty > holdingsBefore.qtyB) {
                $('#new-swap-qty').addClass('is-invalid');
                return { isValid: false, error: `Swap quantity (${newSwapQty.toLocaleString(undefined, qtyDisplayFormat)}) cannot exceed current holding of ${currentPair.stockBTicker} (${holdingsBefore.qtyB.toLocaleString(undefined, qtyDisplayFormat)}).` };
            }
            let swapQty = $('#new-swap-qty').val();
            if (!allowFractionalShares) {
                swapQty = Math.floor(parseFloat(swapQty)).toString();
            }
            return {
                isValid: true,
                trade: {
                    pairId: currentPair.id,
                    date: $('#new-date').val(),
                    swapQty: swapQty,
                    fromTicker: fromTicker,
                    fromPrice: $('#new-from-price').val(),
                    toTicker: $('#new-to-ticker').val(),
                    toPrice: $('#new-to-price').val(),
                    notes: $('#new-notes').val().trim(),
                    isComplete: false
                }
            };
        }
    };

    // --- MAIN APP LOGIC & EVENT HANDLERS ---
    const App = {
        init: async function() {
            // Load shared components first
            $("#header-placeholder").load("../../assets/includes/_header.html?v=" + new Date().getTime(), function() {
                if (typeof initializeHeader === 'function') {
                    initializeHeader();
                }
            });
            $("#navbar-placeholder").load("../../assets/includes/_navbar.html?v=" + new Date().getTime());

            allowFractionalShares = localStorage.getItem('allowFractionalShares') === 'true';
            $('#fractional-shares-switch').prop('checked', allowFractionalShares);
            UI.updateNumberInputs();
            try {
                await DB.init();
                UI.init();
                await this.loadPairs();
                this.bindEvents();
            } catch (error) {
                console.error("Failed to initialize the application:", error);
                UI.showToast('Initialization Failed', 'Could not load database. Please refresh.', true);
            }
        },
        loadPairs: async function() {
            const pairs = await DB.getAll(PAIRS_STORE);
            UI.populatePairSelector(pairs);
            if (pairs.length > 0) {
                const lastSelectedPairId = localStorage.getItem('lastSelectedPairId') || pairs[0].id;
                $('#pair-selector').val(lastSelectedPairId);
            }
            await this.loadPairData();
        },
        loadPairData: async function() {
            const selectedIdStr = $('#pair-selector').val();
            if (!selectedIdStr || selectedIdStr === 'No pairs created') {
                UI.showMainContent(false);
                return;
            }
            const selectedId = parseInt(selectedIdStr);
            localStorage.setItem('lastSelectedPairId', selectedId);
            const pairs = await DB.getAll(PAIRS_STORE);
            currentPair = pairs.find(p => p.id === selectedId);
            if (currentPair) {
                UI.showMainContent(true);
                $('#config-stock-a-label').text(`${currentPair.stockATicker} Initial Qty`);
                $('#config-stock-a-qty').val(currentPair.stockAInitialQty).prop('readonly', true);
                $('#config-stock-b-label').text(`${currentPair.stockBTicker} Initial Qty`);
                $('#config-stock-b-qty').val(currentPair.stockBInitialQty).prop('readonly', true);
                const trades = await DB.getTradesByPairId(currentPair.id);
                UI.renderTradeLog(trades);
                UI.renderNewTradeRow();
                UI.renderPerformance(trades);
            } else {
                UI.showMainContent(false);
            }
        },
        saveNewPair: async function() {
            const newPair = {
                pairName: $('#pair-name').val().trim().toUpperCase(),
                stockATicker: $('#stock-a-ticker').val().trim().toUpperCase(),
                stockBTicker: $('#stock-b-ticker').val().trim().toUpperCase(),
                stockAInitialQty: '0',
                stockBInitialQty: '0'
            };
            $('#pair-name').removeClass('is-invalid');
            const validationResult = await Helpers.validateNewPair(newPair);
            if (!validationResult.isValid) {
                UI.showToast('Validation Error', validationResult.error, true);
                if (validationResult.field === 'pair-name') {
                    $('#pair-name').addClass('is-invalid');
                }
                return;
            }
            const newId = await DB.add(PAIRS_STORE, newPair);
            newPair.id = newId;
            const addDemoData = $('#add-demo-data-checkbox').is(':checked');
            if (addDemoData) {
                newPair.stockAInitialQty = '100';
                newPair.stockBInitialQty = '100';
                await DB.put(PAIRS_STORE, newPair);
                const demoTrades = Helpers.generateDemoTrades(newPair);
                await DB.bulkAdd(TRADES_STORE, demoTrades);
            }
            $('#new-pair-form')[0].reset();
            bootstrap.Modal.getInstance($('#pair-config-modal')).hide();
            await this.loadPairs();
            $('#pair-selector').val(newId);
            await this.loadPairData();
            UI.showToast('Success', `Pair "${newPair.pairName}" created successfully.`);
        },
        saveNewTrade: async function() {
            const validationResult = await Helpers.validateNewTrade();
            if (!validationResult.isValid) {
                UI.showToast('Validation Error', validationResult.error, true);
                return;
            }
            await DB.add(TRADES_STORE, validationResult.trade);
            await this.loadPairData();
            UI.showToast('Success', 'Trade logged successfully.');
        },
        actionHandlers: {
            'clear-log': async function() {
                if (!currentPair) return;
                try {
                    await DB.clearTradesForPair(currentPair.id);
                    await App.loadPairData();
                    UI.showToast('Success', `All trades for "${currentPair.pairName}" have been cleared.`);
                } catch (error) {
                    UI.showToast('Error', 'Failed to clear trade log.', true);
                    console.error('Clear trade log error:', error);
                }
            },
            'clear-db': async function() {
                try {
                    await DB.clearAllData();
                    currentPair = null;
                    localStorage.clear();
                    $('#fractional-shares-switch').prop('checked', false);
                    allowFractionalShares = false;
                    await App.loadPairs();
                    UI.showToast('Success', 'All application data has been cleared.');
                } catch (error) {
                    UI.showToast('Error', 'Failed to clear the database.', true);
                    console.error('Clear database error:', error);
                }
            },
            'add-demo-data': async function() {
                if (!currentPair) return;
                try {
                    currentPair.stockAInitialQty = '100';
                    currentPair.stockBInitialQty = '100';
                    await DB.put(PAIRS_STORE, currentPair);
                    const demoTrades = Helpers.generateDemoTrades(currentPair);
                    await DB.bulkAdd(TRADES_STORE, demoTrades);
                    await App.loadPairData();
                    UI.showToast('Success', `Demo data added to "${currentPair.pairName}".`);
                } catch (error) {
                    UI.showToast('Error', 'Failed to add demo data.', true);
                    console.error('Add demo data error:', error);
                }
            },
            'delete-pair': async function() {
                if (!currentPair) return;
                try {
                    await DB.deletePairAndTrades(currentPair.id);
                    currentPair = null;
                    localStorage.removeItem('lastSelectedPairId');
                    await App.loadPairs();
                    UI.showToast('Success', 'Pair deleted successfully.');
                } catch (error) {
                    UI.showToast('Error', 'Failed to delete pair.', true);
                    console.error('Delete pair error:', error);
                }
            },
            'delete-trade': async function() {
                const tradeId = parseInt($('#confirm-action-modal').data('tradeId'));
                if (isNaN(tradeId)) return;
                try {
                    await DB.delete(TRADES_STORE, tradeId);
                    await App.loadPairData();
                    UI.showToast('Success', 'Trade deleted successfully.');
                } catch (error) {
                    UI.showToast('Error', 'Failed to delete trade.', true);
                    console.error('Delete trade error:', error);
                }
            }
        },
        handleConfirmAction: async function() {
            const action = $('#confirm-action-modal').data('action');
            confirmActionModal.hide();
            const handler = this.actionHandlers[action];
            if (handler) {
                await handler.call(this);
            }
        },
        confirmHistoricTradeUpdate: function() {
            return new Promise(resolve => {
                const modal = $('#confirm-action-modal');
                const confirmBtn = modal.find('#confirm-action-btn');
                modal.find('#confirm-action-modal-title').text('Confirm Trade Update');
                modal.find('#confirm-action-modal-body').html('<p>Are you sure you want to update the existing trade details?</p><p class="text-muted small">Updating an historic trade will change the Outcome and Performance metrics.</p>');
                confirmBtn.text('Confirm').removeClass('btn-danger').addClass('btn-primary');
                const onConfirm = () => {
                    cleanup();
                    resolve(true);
                };
                const onCancel = () => {
                    cleanup();
                    resolve(false);
                };
                const cleanup = () => {
                    confirmBtn.off('click', onConfirm);
                    modal.off('hidden.bs.modal', onCancel);
                    confirmActionModal.hide();
                };
                confirmBtn.one('click', onConfirm);
                modal.one('hidden.bs.modal', onCancel);
                confirmActionModal.show();
            });
        },
        handleTradeUpdate: async function(inputElement) {
            const $input = $(inputElement);
            const $row = $input.closest('tr');
            let tradeId, field;
            if ($row.hasClass('notes-row')) {
                tradeId = $row.data('notes-for-trade-id');
                field = $input.data('field');
            } else {
                const $cell = $input.closest('td');
                tradeId = $row.data('trade-id');
                field = $cell.data('field');
            }
            const newValue = $input.val();
            const trade = await DB.get(TRADES_STORE, tradeId);
            if (!trade || newValue == trade[field]) {
                return this.loadPairData();
            }
            const allTrades = await DB.getTradesByPairId(currentPair.id);
            const latestTradeId = allTrades.length > 0 ? allTrades[allTrades.length - 1].id : null;
            if (tradeId !== latestTradeId) {
                const confirmed = await this.confirmHistoricTradeUpdate();
                if (!confirmed) {
                    return this.loadPairData();
                }
            }
            const validationResult = await Helpers.validateTradeUpdate(trade, field, newValue);
            if (!validationResult.isValid) {
                UI.showToast('Validation Error', validationResult.error, true);
                return this.loadPairData();
            }
            trade[field] = validationResult.sanitizedValue;
            if (field === 'fromTicker') {
                trade.toTicker = (trade.fromTicker === currentPair.stockATicker) ? currentPair.stockBTicker : currentPair.stockATicker;
            }
            await DB.put(TRADES_STORE, trade);
            await this.loadPairData();
            UI.showToast('Success', 'Trade updated successfully.');
        },
        updateInitialQuantity: async function(inputElement) {
            const $input = $(inputElement);
            $input.prop('readonly', true);
            let newValue = $input.val();
            const stockId = $input.attr('id') === 'config-stock-a-qty' ? 'A' : 'B';
            const originalValue = stockId === 'A' ? currentPair.stockAInitialQty : currentPair.stockBInitialQty;
            if (newValue === '' || isNaN(parseFloat(newValue)) || parseFloat(newValue) < 0) {
                UI.showToast('Invalid Input', 'Initial quantity must be a non-negative number.', true);
                $input.val(originalValue);
                return;
            }
            if (!allowFractionalShares) {
                newValue = Math.floor(parseFloat(newValue)).toString();
            }
            if (newValue === originalValue) {
                return;
            }
            if (stockId === 'A') {
                currentPair.stockAInitialQty = newValue;
            } else {
                currentPair.stockBInitialQty = newValue;
            }
            try {
                await DB.put(PAIRS_STORE, currentPair);
                UI.showToast('Success', 'Initial quantity updated.');
                await this.loadPairData();
            } catch (error) {
                UI.showToast('Database Error', 'Could not save changes.', true);
                console.error("Failed to update pair:", error);
                $input.val(originalValue);
            }
        },
        exportToCSV: async function() {
            if (!currentPair) return;
            const trades = await DB.getTradesByPairId(currentPair.id);
            if (trades.length === 0) {
                UI.showToast('Export Failed', 'No trades to export for this pair.', true);
                return;
            }
            let csvContent = "data:text/csv;charset=utf-8,";
            const headers = ["Date", "From Ticker", "From Qty", "From Price", "To Ticker", "To Qty", "To Price", "Notes", "Completed"];
            csvContent += headers.join(",") + "\r\n";
            trades.forEach(trade => {
                const toQty = (parseFloat(trade.fromPrice) / parseFloat(trade.toPrice)) * parseFloat(trade.swapQty);
                const row = [
                    trade.date,
                    trade.fromTicker,
                    trade.swapQty,
                    trade.fromPrice,
                    trade.toTicker,
                    isFinite(toQty) ? toQty.toFixed(8) : '0',
                    trade.toPrice,
                    `"${trade.notes || ''}"`,
                    trade.isComplete || false
                ];
                csvContent += row.join(",") + "\r\n";
            });
            const filename = Helpers.generateExportFilename(currentPair.pairName);
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", filename);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            UI.showToast('Success', 'Trade log exported.');
        },
        importFromCSV: function(event) {
            if (!currentPair) {
                UI.showToast('Import Failed', 'Please select a pair before importing.', true);
                return;
            }
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                const text = e.target.result;
                const rows = text.split('\n').slice(1);
                const tradesToImport = [];
                for (const row of rows) {
                    if (row.trim() === '') continue;
                    const cols = row.split(',');
                    if (cols.length < 9) {
                        UI.showToast('Import Error', `Skipping invalid row: ${row}`, true);
                        continue;
                    }
                    const trade = {
                        pairId: currentPair.id,
                        date: cols[0],
                        fromTicker: cols[1],
                        swapQty: cols[2],
                        fromPrice: cols[3],
                        toTicker: cols[4],
                        toPrice: cols[6],
                        notes: (cols[7] || '').replace(/"/g, ''),
                        isComplete: (cols[8] || '').trim() === 'true'
                    };
                    tradesToImport.push(trade);
                }
                if (tradesToImport.length > 0) {
                    try {
                        await DB.bulkAdd(TRADES_STORE, tradesToImport);
                        await this.loadPairData();
                        UI.showToast('Success', `${tradesToImport.length} trades imported successfully.`);
                    } catch (error) {
                        UI.showToast('Import Failed', 'An error occurred during the database transaction.', true);
                    }
                }
                $('#import-csv-input').val('');
            };
            reader.readAsText(file);
        },
        toggleFractionalShares: function() {
            allowFractionalShares = $('#fractional-shares-switch').is(':checked');
            localStorage.setItem('allowFractionalShares', allowFractionalShares);
            UI.updateNumberInputs();
            if (currentPair) {
                this.loadPairData();
            }
        },
        bindPairEvents: function() {
            $('#save-pair-btn').on('click', this.saveNewPair.bind(this));
            $('#pair-selector').on('change', this.loadPairData.bind(this));
            $('#delete-pair-btn').on('click', function() {
                if (!currentPair) {
                    UI.showToast('Action Failed', 'No pair is currently selected to delete.', true);
                    return;
                }
                $('#confirm-action-modal-title').text('Confirm Pair Deletion');
                $('#confirm-action-modal-body').html(`<p>Are you sure you want to delete the <strong>${currentPair.pairName}</strong> pair and all of its associated trades?</p><p class="text-danger">This action is permanent and cannot be undone.</p>`);
                $('#confirm-action-modal').data('action', 'delete-pair');
                confirmActionModal.show();
            });
            $('#pair-configuration').on('dblclick', 'input[type="number"]', function() {
                $(this).prop('readonly', false).focus().select();
            });
            $('#pair-configuration').on('blur', 'input[type="number"]', (e) => {
                if (!$(e.currentTarget).prop('readonly')) {
                    this.updateInitialQuantity(e.currentTarget);
                }
            });
            $('#pair-configuration').on('keydown', 'input[type="number"]', (e) => {
                if (e.key === 'Enter') {
                    $(e.currentTarget).blur();
                }
            });
        },
        bindTradeLogEvents: function() {
            $(document).on('click', '#date-header', () => {
                UI.dateSortOrder = UI.dateSortOrder === 'asc' ? 'desc' : 'asc';
                this.loadPairData();
            });
            const tradeLogBody = $('#trade-log-body');
            tradeLogBody.on('click', '.notes-icon-btn', function() {
                const $row = $(this).closest('tr');
                const tradeId = $row.data('trade-id');
                $(`tr[data-notes-for-trade-id="${tradeId}"]`).toggleClass('d-none');
            });
            tradeLogBody.on('dblclick', 'textarea.notes-editor', function() {
                const $textarea = $(this);
                $textarea.prop('readonly', false).focus();
                this.selectionStart = this.selectionEnd = this.value.length;
                const $cell = $textarea.closest('td');
                $cell.find('.edit-note-helper').remove();
                $cell.append('<div class="form-text mt-1 edit-note-helper">Press Enter to save, or Esc to cancel.</div>');
            });
            tradeLogBody.on('blur', 'textarea.notes-editor', (e) => {
                if (!$(e.currentTarget).prop('readonly')) {
                    App.handleTradeUpdate(e.currentTarget);
                }
            });
            tradeLogBody.on('keydown', 'textarea.notes-editor', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    $(e.currentTarget).blur();
                }
                if (e.key === 'Escape') {
                    App.loadPairData();
                }
            });
            tradeLogBody.on('dblclick', '.editable-cell', async function() {
                const $cell = $(this);
                if ($cell.find('input, select').length > 0) return;
                const $row = $cell.closest('tr');
                const tradeId = $row.data('trade-id');
                const field = $cell.data('field');
                const trade = await DB.get(TRADES_STORE, tradeId);
                if (!trade) return;
                const currentValue = trade[field];
                const inputHtml = UI.createCellEditor(field, currentValue);
                $cell.html(inputHtml);
                const $input = $cell.find('input, select');
                $input.focus().select();
                $input.on('blur', () => App.handleTradeUpdate($input[0]));
                $input.on('keydown', (e) => {
                    if (e.key === 'Enter') $input.blur();
                    if (e.key === 'Escape') App.loadPairData();
                });
            });
            tradeLogBody.on('click', '.delete-trade-btn', function() {
                const tradeId = $(this).data('trade-id');
                $('#confirm-action-modal-title').text('Confirm Trade Deletion');
                $('#confirm-action-modal-body').html('<p>Are you sure you want to delete this trade? This action is permanent and cannot be undone.</p>');
                $('#confirm-action-modal').data('action', 'delete-trade').data('tradeId', tradeId);
                confirmActionModal.show();
            });
            tradeLogBody.on('change', '.swap-back-toggle', async function() {
                const checkbox = this;
                const tradeId = $(checkbox).data('trade-id');
                const isNowComplete = $(checkbox).is(':checked');
                try {
                    const trade = await DB.get(TRADES_STORE, tradeId);
                    if (trade) {
                        trade.isComplete = isNowComplete;
                        await DB.put(TRADES_STORE, trade);
                        await App.loadPairData();
                        const toastMessage = isNowComplete ? 'Trade marked as complete.' : 'Trade status reset to incomplete.';
                        UI.showToast('Success', toastMessage);
                    }
                } catch (error) {
                    console.error('Failed to update trade status:', error);
                    UI.showToast('Error', 'Could not update trade status.', true);
                    $(checkbox).prop('checked', !isNowComplete);
                }
            });
        },
        bindNewTradeRowEvents: function() {
            const newTradeRow = $('#new-trade-body');
            newTradeRow.on('click', '#save-trade-btn', this.saveNewTrade.bind(this));
            newTradeRow.on('change', '#new-from-ticker', UI.updateToTicker.bind(UI));
            newTradeRow.on('input', '#new-from-price, #new-to-price, #new-swap-qty', UI.updateCalculatedFields.bind(UI));
            newTradeRow.on('dblclick', '#new-to-qty', function() {
                $(this).prop('readonly', false).removeClass('bg-body-secondary').addClass('bg-body');
                UI.isToQtyCalculated = false;
            });
        },
        bindModalAndConfirmationEvents: function() {
            $('#confirm-action-btn').on('click', this.handleConfirmAction.bind(this));
        },
        bindSettingsAndDataManagementEvents: function() {
            $('#export-csv-btn').on('click', this.exportToCSV.bind(this));
            $('#import-csv-input').on('change', this.importFromCSV.bind(this));
            $('#fractional-shares-switch').on('change', this.toggleFractionalShares.bind(this));
            $('#data-management-collapse, #settings-collapse').on('shown.bs.collapse hidden.bs.collapse', () => {
                localStorage.setItem('isDataManagementExpanded', $('#data-management-collapse').hasClass('show'));
                localStorage.setItem('isSettingsExpanded', $('#settings-collapse').hasClass('show'));
            });
            $('#add-demo-data-btn').on('click', function() {
                if (!currentPair) return;
                $('#confirm-action-modal-title').text('Add Demo Data');
                $('#confirm-action-modal-body').html(`<p>Are you sure you want to add demo trades to the <strong>${currentPair.pairName}</strong> pair?</p><p class="text-muted">This will also reset the initial quantities for this pair to 100.</p>`);
                $('#confirm-action-modal').data('action', 'add-demo-data');
                confirmActionModal.show();
            });
            $('#clear-log-btn').on('click', function() {
                if (currentPair) {
                    $('#confirm-action-modal-title').text('Clear Trade Log');
                    $('#confirm-action-modal-body').html(`<p>Are you sure you want to clear all trades for the <strong>${currentPair.pairName}</strong> pair?</p><p class="text-danger">This action cannot be undone.</p>`);
                    $('#confirm-action-modal').data('action', 'clear-log');
                    confirmActionModal.show();
                }
            });
            $('#clear-db-btn').on('click', function() {
                $('#confirm-action-modal-title').text('Clear Entire Database');
                $('#confirm-action-modal-body').html(`<p>Are you sure you want to delete <strong>ALL</strong> pairs and trades from the database?</p><p class="text-danger">This action is permanent and cannot be undone.</p>`);
                $('#confirm-action-modal').data('action', 'clear-db');
                confirmActionModal.show();
            });
        },
        bindEvents: function() {
            this.bindPairEvents();
            this.bindTradeLogEvents();
            this.bindNewTradeRowEvents();
            this.bindModalAndConfirmationEvents();
            this.bindSettingsAndDataManagementEvents();
        }
    };

    // --- INITIALIZE APP ---
    App.init();
});
